library(foreign)
df <- read.spss("dataset.sav", use.value.label=TRUE, to.data.frame=TRUE)
library(foreign)
df <- read.spss("/Users/amlan/Downloads/Weapons IAT.public.2017.sav", use.value.label=TRUE, to.data.frame=TRUE)
getwd()
write.csv(df,"/USers/amlan/weapon.csv")
library(shiny)
# Define UI for app that draws a histogram ----
ui <- fluidPage(
# App title ----
titlePanel("Hello Shiny!"),
# Sidebar layout with input and output definitions ----
sidebarLayout(
# Sidebar panel for inputs ----
sidebarPanel(
# Input: Slider for the number of bins ----
sliderInput(inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
)
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#75AADB", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
View(server)
View(ui)
shiny::runApp('Documents/codebase/github/CSE_587_Data_Intensive_Computing/Lab1/part3/shiny')
library(tigris)
library(dplyr)
library(leaflet)
# Downloading the shapefiles for states at the lowest resolution
states <- states(cb=T)
states %>%
leaflet() %>%
addTiles() %>%
addPolygons(popup=~NAME)
starbucks <- read.csv("data/starbucks.csv", stringsAsFactors=F)
# First, we'll use dplyr to summarize the data
# count by state
sb_state <- starbucks %>%
group_by(Province) %>%
summarize(total=n()) %>%
# Some quick adjustments to the the dataframe to clean up names
mutate(type = "Starbucks") %>%
rename(state=Province)
View(starbucks)
# First, we'll use dplyr to summarize the data
# count by state
sb_state <- starbucks %>%
group_by(State) %>%
summarize(total=n()) %>%
# Some quick adjustments to the the dataframe to clean up names
mutate(type = "Starbucks") %>%
rename(state=State)
View(sb_state)
View(states)
# Now we use the Tigris function geo_join to bring together
# the states shapefile and the sb_states dataframe -- STUSPS and state
# are the two columns they'll be joined by
states_merged_sb <- geo_join(states, sb_state, "STUSPS", "state")
# Creating a color palette based on the number range in the total column
pal <- colorNumeric("Greens", domain=states_merged_sb$total)
# Getting rid of rows with NA values
# Using the Base R method of filtering subset() because we're dealing with a SpatialPolygonsDataFrame and not a normal data frame, thus filter() wouldn't work
states_merged_sb <- subset(states_merged_sb, !is.na(total))
# Setting up the pop up text
popup_sb <- paste0("Total: ", as.character(states_merged_sb$total))
View(states_merged_sb)
View(pal)
View(states_merged_sb)
# Mapping it with the new tiles CartoDB.Positron
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
setView(-98.483330, 38.712046, zoom = 4) %>%
addPolygons(data = states_merged_sb ,
fillColor = ~pal(states_merged_sb$total),
fillOpacity = 0.7,
weight = 0.2,
smoothFactor = 0.2,
popup = ~popup_sb) %>%
addLegend(pal = pal,
values = states_merged_sb$total,
position = "bottomright",
title = "Starbucks")
states_merged_sb$total
shiny::runApp()
runApp()
fluTweet <- read.csv(file="data/twitter_data.csv", header=TRUE, sep=",")
nrow(fluTweet)
View(fluTweet)
fluTweet <- fluTweet[!(is.na(fluTweet$lat) | fluTweet$lat==""), ]
nrow(fluTweet)
fluTweet <- unique(fluTweet, by = "status_id")
nrow(fluTweet)
library(tigris)
library(plyr)
library(dplyr)
library(leaflet)
library(maps)
library(maptools)
library(sp)
testPoints <- data.frame(x = fluTweet$lng, y = fluTweet$lat)
states <- map('state', fill=TRUE, col="transparent", plot=FALSE)
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
states_sp <- map2SpatialPolygons(states, IDs=IDs,
proj4string=CRS("+proj=longlat +datum=WGS84"))
pointsSP <- SpatialPoints(testPoints,
proj4string=CRS("+proj=longlat +datum=WGS84"))
indices <- over(pointsSP, states_sp)
stateNames <- sapply(states_sp@polygons, function(x) x@ID)
fluTweet$state <- stateNames[indices]
fluTweet <- fluTweet[!(is.na(fluTweet$state) | fluTweet$state==""), ]
View(fluTweet)
View(states_sp)
View(testPoints)
testPoints <- data.frame(x = fluTweet$lng, y = fluTweet$lat)
states <- map('state', fill=TRUE, col="transparent", plot=FALSE)
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
states_sp <- map2SpatialPolygons(states, IDs=IDs,
proj4string=CRS("+proj=longlat +datum=WGS84"))
pointsSP <- SpatialPoints(testPoints,
proj4string=CRS("+proj=longlat +datum=WGS84"))
indices <- over(pointsSP, states_sp)
stateNames <- sapply(states_sp@polygons, function(x) x@ID)
fluTweet$state <- stateNames[indices]
fluTweet <- fluTweet[!(is.na(fluTweet$state) | fluTweet$state==""), ]
count_by_state<- fluTweet %>% count(state)
View(count_by_state)
View(sb_state)
View(starbucks)
View(count_by_state)
colnames(count_by_state) <- c("NAME", "Tweets")
View(count_by_state)
colnames(count_by_state) <- c("NAME", "TWEETS")
View(count_by_state)
state_off <- data.frame(state.abb, state.name)
head(state_off)
colnames(state_off) <- c("state", "NAME")
View(state_off)
state_off$NAME <-tolower(state_off$NAME)
View(state_off)
state_tweets <- left_join(count_by_state, state_off)
View(state_tweets)
View(states_merged_sb)
View(sb_state)
View(state_tweets)
# Now we use the Tigris function geo_join to bring together
# the states shapefile and the sb_states dataframe -- STUSPS and state
# are the two columns they'll be joined by
states_merged_sb <- geo_join(states, state_tweets, "STUSPS", "state")
# Creating a color palette based on the number range in the total column
pal <- colorNumeric("Greens", domain=states_merged_sb$total)
# Getting rid of rows with NA values
# Using the Base R method of filtering subset() because we're dealing with a SpatialPolygonsDataFrame and not a normal data frame, thus filter() wouldn't work
states_merged_sb <- subset(states_merged_sb, !is.na(total))
# Setting up the pop up text
popup_sb <- paste0("Total: ", as.character(states_merged_sb$total))
# Mapping it with the new tiles CartoDB.Positron
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
setView(-98.483330, 38.712046, zoom = 4) %>%
addPolygons(data = states_merged_sb ,
fillColor = ~pal(states_merged_sb$total),
fillOpacity = 0.7,
weight = 0.2,
smoothFactor = 0.2,
popup = ~popup_sb) %>%
addLegend(pal = pal,
values = states_merged_sb$total,
position = "bottomright",
title = "Starbucks")
states_merged_sb <- geo_join(states, state_tweets, "STUSPS", "state")
states <- states(cb=T)
states %>%
leaflet() %>%
addTiles() %>%
addPolygons(popup=~NAME)
states_merged_sb <- geo_join(states, state_tweets, "STUSPS", "state")
View(states_merged_sb)
# Creating a color palette based on the number range in the total column
pal <- colorNumeric("Greens", domain=states_merged_sb$total)
View(pal)
states_merged_sb <- subset(states_merged_sb, !is.na(total))
View(state_tweets)
# Creating a color palette based on the number range in the total column
pal <- colorNumeric("Greens", domain=states_merged_sb$TWEETS)
# Getting rid of rows with NA values
# Using the Base R method of filtering subset() because we're dealing with a SpatialPolygonsDataFrame and not a normal data frame, thus filter() wouldn't work
states_merged_sb <- subset(states_merged_sb, !is.na(TWEETS))
# Setting up the pop up text
popup_sb <- paste0("Total: ", as.character(states_merged_sb$TWEETS))
# Mapping it with the new tiles CartoDB.Positron
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
setView(-98.483330, 38.712046, zoom = 4) %>%
addPolygons(data = states_merged_sb ,
fillColor = ~pal(states_merged_sb$TWEETS),
fillOpacity = 0.7,
weight = 0.2,
smoothFactor = 0.2,
popup = ~popup_sb) %>%
addLegend(pal = pal,
values = states_merged_sb$total,
position = "bottomright",
title = "TWEETS")
Mapping it with the new tiles CartoDB.Positron
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
setView(-98.483330, 38.712046, zoom = 4) %>%
addPolygons(data = states_merged_sb ,
fillColor = ~pal(states_merged_sb$TWEETS),
fillOpacity = 0.7,
weight = 0.2,
smoothFactor = 0.2,
popup = ~popup_sb) %>%
addLegend(pal = pal,
values = states_merged_sb$TWEETS,
position = "bottomright",
title = "TWEETS")
library(tigris)
library(plyr)
library(dplyr)
library(leaflet)
library(maps)
library(maptools)
library(sp)
library(data.table)
# read collected tweets from csv
fluTweet <- read.csv(file="data/twitter_data.csv", header=TRUE, sep=",")
# clean data: keep data with longitude and latitude value and remove duplicates
fluTweet <- fluTweet[!(is.na(fluTweet$lat) | fluTweet$lat==""), ]
fluTweet <- unique(fluTweet, by = "status_id")
testPoints <- data.frame(x = fluTweet$lng, y = fluTweet$lat)
states <- map('state', fill=TRUE, col="transparent", plot=FALSE)
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
states_sp <- map2SpatialPolygons(states, IDs=IDs,
proj4string=CRS("+proj=longlat +datum=WGS84"))
pointsSP <- SpatialPoints(testPoints,
proj4string=CRS("+proj=longlat +datum=WGS84"))
indices <- over(pointsSP, states_sp)
stateNames <- sapply(states_sp@polygons, function(x) x@ID)
fluTweet$state <- stateNames[indices]
fluTweet <- fluTweet[!(is.na(fluTweet$state) | fluTweet$state==""), ]
count_by_state<- fluTweet %>% count(state)
colnames(count_by_state) <- c("NAME", "TWEETS")
state_off <- data.frame(state.abb, state.name)
colnames(state_off) <- c("state", "NAME")
state_off$NAME <-tolower(state_off$NAME)
state_tweets <- left_join(count_by_state, state_off)
# Downloading the shapefiles for states at the lowest resolution
states <- states(cb=T)
states %>%
leaflet() %>%
addTiles() %>%
addPolygons(popup=~NAME)
# Now we use the Tigris function geo_join to bring together
# the states shapefile and the sb_states dataframe -- STUSPS and state
# are the two columns they'll be joined by
states_merged_sb <- geo_join(states, state_tweets, "STUSPS", "state")
# Creating a color palette based on the number range in the total column
pal <- colorNumeric("Greens", domain=states_merged_sb$TWEETS)
# Getting rid of rows with NA values
# Using the Base R method of filtering subset() because we're dealing with a SpatialPolygonsDataFrame and not a normal data frame, thus filter() wouldn't work
states_merged_sb <- subset(states_merged_sb, !is.na(TWEETS))
# Setting up the pop up text
popup_sb <- paste0("Total: ", as.character(states_merged_sb$TWEETS))
# Mapping it with the new tiles CartoDB.Positron
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
setView(-98.483330, 38.712046, zoom = 4) %>%
addPolygons(data = states_merged_sb ,
fillColor = ~pal(states_merged_sb$TWEETS),
fillOpacity = 0.7,
weight = 0.2,
smoothFactor = 0.2,
popup = ~popup_sb) %>%
addLegend(pal = pal,
values = states_merged_sb$TWEETS,
position = "bottomright",
title = "TWEETS")
shiny::runApp()
library(shiny)
library(tigris)
library(plyr)
library(dplyr)
library(leaflet)
library(maps)
library(maptools)
library(sp)
library(shinycssloaders)
### Common Execution ###
########################
# Downloading the shapefiles for states at the lowest resolution
states <- states(cb=T)
dropdown_choices <- read.csv(file="data/dropdowns.csv", header=FALSE)$V1
# read collected tweets from csv
fluTweet <- read.csv(file="data/twitter_data.csv", header=TRUE, sep=",")
# clean data: keep data with longitude and latitude value and remove duplicates
fluTweet <- fluTweet[!(is.na(fluTweet$lat) | fluTweet$lat==""), ]
fluTweet <- unique(fluTweet, by = "status_id")
# Get state list
state_off <- data.frame(state.abb, state.name)
colnames(state_off) <- c("state", "NAME")
state_off$NAME <-tolower(state_off$NAME)
testPoints <- data.frame(x = fluTweet$lng, y = fluTweet$lat)
states <- map('state', fill=TRUE, col="transparent", plot=FALSE)
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
states_sp <- map2SpatialPolygons(states, IDs=IDs,
proj4string=CRS("+proj=longlat +datum=WGS84"))
pointsSP <- SpatialPoints(testPoints,
proj4string=CRS("+proj=longlat +datum=WGS84"))
indices <- over(pointsSP, states_sp)
stateNames <- sapply(states_sp@polygons, function(x) x@ID)
fluTweet$state <- stateNames[indices]
fluTweet <- fluTweet[!(is.na(fluTweet$state) | fluTweet$state==""), ]
####### End Common Execution ####
View(states)
count_by_state<- fluTweet %>% count(state)
colnames(count_by_state) <- c("NAME", "TWEETS")
state_tweets <- left_join(count_by_state, state_off)
states_merged_sb <- geo_join(states, state_tweets, "STUSPS", "state")
# Creating a color palette based on the number range in the total column
pal <- colorNumeric("Greens", domain=states_merged_sb$TWEETS)
# Getting rid of rows with NA values
# Using the Base R method of filtering subset() because we're dealing with a SpatialPolygonsDataFrame and not a normal data frame, thus filter() wouldn't work
states_merged_sb <- subset(states_merged_sb, !is.na(TWEETS))
# Setting up the pop up text
#popup_sb <- paste0("Total: ", as.character(states_merged_sb$TWEETS))
popup_sb <- paste0("<strong>", states_merged_sb$NAME,
count_by_state<- fluTweet %>% count(state)
colnames(count_by_state) <- c("NAME", "TWEETS")
View(count_by_state)
View(state_tweets)
View(states)
states <- states(cb=T)
states_merged_sb <- geo_join(states, state_tweets, "STUSPS", "state")
library(shiny)
library(tigris)
library(plyr)
library(dplyr)
library(leaflet)
library(maps)
library(maptools)
library(sp)
library(shinycssloaders)
### Common Execution ###
########################
# Downloading the shapefiles for states at the lowest resolution
states_import <- states(cb=T)
dropdown_choices <- read.csv(file="data/dropdowns.csv", header=FALSE)$V1
# read collected tweets from csv
fluTweet <- read.csv(file="data/twitter_data.csv", header=TRUE, sep=",")
# clean data: keep data with longitude and latitude value and remove duplicates
fluTweet <- fluTweet[!(is.na(fluTweet$lat) | fluTweet$lat==""), ]
fluTweet <- unique(fluTweet, by = "status_id")
# Get state list
state_off <- data.frame(state.abb, state.name)
colnames(state_off) <- c("state", "NAME")
state_off$NAME <-tolower(state_off$NAME)
testPoints <- data.frame(x = fluTweet$lng, y = fluTweet$lat)
states <- map('state', fill=TRUE, col="transparent", plot=FALSE)
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
states_sp <- map2SpatialPolygons(states, IDs=IDs,
proj4string=CRS("+proj=longlat +datum=WGS84"))
pointsSP <- SpatialPoints(testPoints,
proj4string=CRS("+proj=longlat +datum=WGS84"))
indices <- over(pointsSP, states_sp)
stateNames <- sapply(states_sp@polygons, function(x) x@ID)
fluTweet$state <- stateNames[indices]
fluTweet <- fluTweet[!(is.na(fluTweet$state) | fluTweet$state==""), ]
####### End Common Execution ####
count_by_state<- fluTweet %>% count(state)
colnames(count_by_state) <- c("NAME", "TWEETS")
state_tweets <- left_join(count_by_state, state_off)
states_merged_sb <- geo_join(states_import, state_tweets, "STUSPS", "state")
# Creating a color palette based on the number range in the total column
pal <- colorNumeric("Greens", domain=states_merged_sb$TWEETS)
# Getting rid of rows with NA values
# Using the Base R method of filtering subset() because we're dealing with a SpatialPolygonsDataFrame and not a normal data frame, thus filter() wouldn't work
states_merged_sb <- subset(states_merged_sb, !is.na(TWEETS))
# Setting up the pop up text
#popup_sb <- paste0("Total: ", as.character(states_merged_sb$TWEETS))
popup_sb <- paste0("<strong>", states_merged_sb$NAME,
"</strong><br />Tweets: ", states_merged_sb$TWEETS)
runApp()
